第一个要写的接口  果然就是登录了
## 表结构
和一般的用户表设计不同  我这里将用户表分成了两张表
users   
```
DROP TABLE IF EXISTS "public"."users";
CREATE TABLE "public"."users" (
  "id" int4 NOT NULL GENERATED BY DEFAULT AS IDENTITY (
INCREMENT 1
MINVALUE  1
MAXVALUE 2147483647
START 1
CACHE 1
),
  "username" varchar(10) COLLATE "pg_catalog"."default" NOT NULL,
  "nickname" varchar COLLATE "pg_catalog"."default" NOT NULL,
  "name" varchar COLLATE "pg_catalog"."default",
  "created_at" timestamptz(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" timestamptz(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "deleted_at" timestamptz(6),
  "status" int2 NOT NULL,
  "signature" varchar COLLATE "pg_catalog"."default",
  "avatar" varchar(50) COLLATE "pg_catalog"."default" NOT NULL,
  "sex" int2 NOT NULL,
  "mobile" varchar(20) COLLATE "pg_catalog"."default" NOT NULL,
  "id_card_num" varchar(20) COLLATE "pg_catalog"."default",
  "birth" timestamptz(6)
)
;
```

user_auths
```
DROP TABLE IF EXISTS "public"."user_auths";
CREATE TABLE "public"."user_auths" (
  "id" int4 NOT NULL GENERATED BY DEFAULT AS IDENTITY (
INCREMENT 1
MINVALUE  1
MAXVALUE 2147483647
START 1
CACHE 1
),
  "user_id" int4 NOT NULL,
  "identity_kind" int2 NOT NULL,
  "identifier" varchar COLLATE "pg_catalog"."default" NOT NULL,
  "credential" varchar COLLATE "pg_catalog"."default" NOT NULL,
  "created_at" timestamptz(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" timestamptz(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "deleted_at" timestamptz(6),
  "verified" int2 NOT NULL,
  "ip" varchar(20) COLLATE "pg_catalog"."default",
  "ip_location" varchar(20) COLLATE "pg_catalog"."default"
)
;
```

相比于正常的表结构 这种方式的优劣就不在这里赘述了  或许到时候会新建一个文档写一下？

## Model
我们首先从model层开始写
在model文件夹下新建usermodel文件夹  用来存储users这张表的各种方法
并且在这个文件夹下打开终端
gozero对于postgresql在model层的代码生成与mysql并不相同
使用mysql时可以将表结构存为sql文件再生成，但是postgresql需要使用另外一种方式
```
goctl model pg datasource --url "postgres://root:123456@127.0.0.1:15433/databasename?sslmode=disable" -t "tablename" -d . -c
```
将命令中的各个参数替换掉来生成model层代码
很重要的一点   ==gozero会根据表中的唯一键 来生成相应的查询方法==
关于生成代码的讲解 推荐大家去看[Mikaelemmmm](https://github.com/Mikaelemmmm/go-zero-looklook/commits?author=Mikaelemmmm)大佬的[go-zero-looklook](https://github.com/Mikaelemmmm/go-zero-looklook)项目  相当NB  在B站还有配套的视频教程

## RPC
在model层的代码写完之后  我们要开始RPC的代码了
在rpc文件夹下新建user文件夹 用来存储user的rpc代码
在user下新建user.proto和user_model.proto

user.proto
```
syntax = "proto3";  
  
package user;  
option go_package = "./userRpcModel";  
import "user_model.proto";  
message ReqCreateUser {  
  userrpcmodel.User info=1;  
}  
  
message ResUser {  
  userrpcmodel.User info=1;  
}  
message ReqId{  
  int64 id=1;  
}  
service UserService {  
  rpc CreateUser(ReqCreateUser) returns (ResUser);  
  rpc GetUserById(ReqId)returns (ResUser);  
  rpc UpdateUser(ReqCreateUser) returns (ResUser);  
}
```

user_model.proto
```
syntax = "proto3";  
  
package userrpcmodel;  
option go_package = "./userRpcModel";  
message User {  
  int64 id = 1;  
  string username = 2;  
  string nickname = 3;  
  string name = 4;  
  string created_at = 5;  
  string updated_at = 6;  
  string deleted_at = 7;  
  int64 status = 8;  
  string signature = 9;  
  string avatar = 10;  
  int64 sex = 11;  
  string mobile = 12;  
  string id_card_num = 13;  
  string birth = 14;  
}
```
先讲一下为什么要使用两个proto文件吧
用户的rpc层我们不会只有这一张表   以后可能会做钱包  实名认证   朋友圈  会员等各种各样的功能 都是需要建相应的表来存储的      所以我想尽可能的减少user.proto文件的长度，免得到时候一大长串  找个东西找半天的情况
user.proto中引入user_model.proto文件  关于proto文件的导入 在gozero的官方文档中也有详细介绍
[常见问题 | go-zero Documentation](https://go-zero.dev/docs/tutorials/proto/faq)


对于user_model.proto  我们需要先使用其他命令来生成代码
```
protoc -I ./ --go_out=. --go-grpc_out=.   .\user_model.proto 
```

接着使用
```
goctl rpc protoc user.proto --go_out=./ --go-grpc_out=./ --zrpc_out=./   -m --style=goZero
//--style=goZero影响的是生成的文件命名格式  可以随自己喜欢不要这一句 也可以改为gozero  go_zero
```

来生成rpc层的代码

